////////////////////////////////////////////////////////////////////////////////
//
//  ADOBE SYSTEMS INCORPORATED
//  Copyright 2004-2007 Adobe Systems Incorporated
//  All Rights Reserved.
//
//  NOTICE: Adobe permits you to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
//
////////////////////////////////////////////////////////////////////////////////

package flex2.compiler.mxml.rep;

import flex2.compiler.mxml.gen.TextGen;
import flex2.compiler.mxml.lang.StandardDefs;
import flex2.compiler.mxml.reflect.*;
import flex2.compiler.mxml.rep.init.*;
import flex2.compiler.util.IteratorList;
import flex2.compiler.util.NameFormatter;
import org.apache.commons.collections.Predicate;
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.iterators.FilterIterator;
import org.apache.commons.collections.iterators.IteratorChain;
import org.apache.commons.collections.iterators.TransformIterator;

import java.util.*;

public class Model implements LineNumberMapped
{
	private Type type;

	/**
	 * line number where this model occurred in xml.  -1 if this model
	 * is synthetic and has no creation site in MXML.
	 */
	private int xmlLineNumber;

	/**
	 * this is the guaranteed-unique name used by the value initializer
	 * TODO see below
	 */
	private String definitionName;

	/**
	 * this is the ID we have given this instance in mxml.  it will either be user assigned or
	 * assigned automatically by the compiler.
	 * NOTE: in anonymous cases (e.g. XML), this may be a child element name, thus not guaranteed unique.
	 * TODO id should be the guaranteed-unique one; childName or something for the other one.
	 */
	private String id;

	/**
	 * this flag is true if the id (see above) was assigned automatically
	 * by the compiler.  Conversely, this flag is false if the user
	 * explicitly assigned the id
	 */
	private boolean idIsAutogenerated = false;

	/**
	 * indicates whether this Model is a child of an AnonymousObjectGraph
	 */
	private boolean isAnonymous = false;

	private MxmlDocument document;

	private Model parent;
	private String parentIndex;

	private boolean inspectable = false;

	private List repeaterParents;

	private Map properties;
	private Map styles;
	private Map effects;
	private Map events;

	private boolean described;	//	TODO remove when DI is generalized

	public Model(MxmlDocument document, Type type, int line)
	{
		this(document, type, null, line);
	}

	public Model(MxmlDocument document, Type type, Model parent, int line)
	{
		assert (type != null);

		this.document = document;
		this.type = type;
		this.parent = parent;
		setXmlLineNumber(line);

		document.ensureId(this);
        setDefinitionName(getId());
	}

	public final boolean isDeclared()
	{
		//	TODO first clause is necessary due to id being abused in AOG case (see AOGBuilder ~line 85.
		//  This breaks meaning of id - need to find another way to enable correct databinding codegen in AOG case.
		return !isAnonymous && document.isDeclared(this);
	}

	public final Type getType()
	{
		return type;
	}

	public final String getDefinitionName()
	{
		return definitionName;
	}

	public final void setDefinitionName(String definitionName)
	{
		this.definitionName = definitionName;
	}

	public final String getId()
	{
		return id;
	}

	public final void setId(String id, boolean idIsAutogenerated)
	{
		this.id = id;
		this.idIsAutogenerated = idIsAutogenerated;
	}

	public final boolean getIdIsAutogenerated()
	{
		return idIsAutogenerated;
	}

	public final boolean getIsAnonymous()
	{
		return isAnonymous;
	}

	public final void setIsAnonymous(boolean isAnonymous)
	{
		this.isAnonymous = isAnonymous;
	}

	public final MxmlDocument getDocument()
	{
		return document;
	}

	public final void setParent(Model parent)
	{
		this.parent = parent;
	}

	public final Model getParent()
	{
		return parent;
	}

	public final void setParentIndex(String index)
	{
		this.parentIndex = index;
	}

	public final void setParentIndex(int index)
	{
		this.parentIndex = Integer.toString(index);
	}

	public final String getParentIndex()
	{
		return parentIndex;
	}

	public final int getXmlLineNumber()
	{
		return xmlLineNumber;
	}

	public final void setXmlLineNumber(int xmlLineNumber)
	{
		this.xmlLineNumber = xmlLineNumber;
	}

	public final boolean getInspectable()
	{
		return inspectable;
	}

	public final void setInspectable(boolean inspectable)
		{
		this.inspectable = inspectable;
		}

	public final int getRepeaterLevel()
	{
		return getRepeaterParents().size();
	}

	public final List getRepeaterParents()
	{
		if (repeaterParents == null)
		{
			repeaterParents = new ArrayList();

			if (parent != null)
			{
				repeaterParents.addAll(parent.getRepeaterParents());

				if (StandardDefs.isRepeater(parent.getType()))
				{
					repeaterParents.add(parent);
				}
			}
		}

		return repeaterParents;
	}

	/**
	 *
	 */
	public void setProperty(String name, Model value)
	{
		setProperty(name, value, value.getXmlLineNumber());
	}

	/**
	 *
	 */
	public void setProperty(Property property, Object value, int line)
	{
		Initializer initializer = new StaticPropertyInitializer(property, value, line);
		(properties != null ? properties : (properties = new LinkedHashMap())).put(property.getName(), initializer);
	}

	/**
	 *
	 */
	public void setDynamicProperty(Type type, String name, Object value, int line)
	{
		Initializer initializer = new DynamicPropertyInitializer(type, name, value, line);
		(properties != null ? properties : (properties = new LinkedHashMap())).put(name, initializer);
	}

	/**
	 * TODO legacy shim. Convert all callers to either setProperty(property, value) or setDynamicProperty(type, name, value)
	 */
	public void setProperty(String name, Object value, int line)
	{
		Property property = type.getProperty(name);
		if (property != null)
		{
			setProperty(property, value, line);
		}
		else
		{
			setDynamicProperty(type.getTypeTable().objectType, name, value, line);
		}
	}

	/**
	 *
	 */
	public final boolean hasProperty(String name)
	{
		return getProperties().containsKey(name);
	}

	/**
	 *
	 */
	public boolean hasBindings()
	{
		return bindingsOnly(getProperties().values().iterator()).hasNext() ||
				bindingsOnly(getStyles().values().iterator()).hasNext() ||
				bindingsOnly(getEffects().values().iterator()).hasNext();
	}

	/**
	 * Note that we do *not* filter out bindings by default for property initializers.
	 */
	public final Iterator getPropertyInitializerIterator()
	{
		return getPropertyInitializerIterator(true);
	}

	/**
	 *
	 */
	public final Iterator getPropertyInitializerIterator(boolean includeBindings)
	{
		return includeBindings ?
				getProperties().values().iterator() :
				excludeBindings(getProperties().values().iterator());
	}

	/**
	 *
	 */
	public boolean isEmpty()
	{
		return properties == null && styles == null && effects == null && events == null;
	}

	/**
	 * TODO make this private once RemoteObjectBuilder usage has been removed
	 */
	public final Map getProperties()
	{
		return properties != null ? properties : Collections.EMPTY_MAP;
	}

	/**
	 * TODO legacy - delete once AnonymousObjectGraphBuilder usage has been removed
	 */
	public Object getProperty(String name)
	{
        ValueInitializer initializer = (ValueInitializer)getProperties().get(name);
		return initializer != null ? initializer.getValue() : null;
	}

	/**
	 *
	 */
	public final void setStyle(String name, Object value, int line)
	{
		Style style = type.getStyle(name);
		assert style != null : "style '" + name + "' not defined on type '" + type.getName() + "'";;
		StyleInitializer styleInitializer = new StyleInitializer(style, value, line);
		(styles != null ? styles : (styles = new LinkedHashMap())).put(name, styleInitializer);
	}

	public final Iterator getStyleInitializerIterator()
	{
		return excludeBindings(getStyles().values().iterator());
	}

	public final boolean hasStyle(String name)
	{
		return getStyles().containsKey(name);
	}

	private Map getStyles()
	{
		return styles != null ? styles : Collections.EMPTY_MAP;
	}

	/**
	 * Note: this is a little irregular; effect rvalues are either class names or bindings.
	 */
	public final void setEffect(String name, Object value, Type effectType, int line)
	{
		Effect effect = type.getEffect(name);
		assert effect != null : "effect '" + name + "' not defined on type '" + type.getName() + "'";
		EffectInitializer effectInitializer = new EffectInitializer(effect, value, effectType, line);
		(effects != null ? effects : (effects = new LinkedHashMap())).put(name, effectInitializer);
	}

	public final Iterator getEffectInitializerIterator()
	{
		return excludeBindings(getEffects().values().iterator());
	}

	public final boolean hasEffect(String name)
	{
		return getEffects().containsKey(name);
	}

	private final Map getEffects()
	{
		return effects != null ? effects : Collections.EMPTY_MAP;
	}

	public String getEffectNames()
	{
		Iterator eventNameIter = new TransformIterator(getEffectInitializerIterator(), new Transformer()
		{
			public Object transform(Object object)
			{
				return TextGen.quoteWord(((EffectInitializer)object).getName());
			}
		});

		return TextGen.toCommaList(eventNameIter);
	}

	public String getEffectEventNames()
	{
		Iterator eventNameIter = new TransformIterator(getEffectInitializerIterator(), new Transformer()
		{
			public Object transform(Object object)
			{
				return TextGen.quoteWord(((EffectInitializer)object).getEventName());
			}
		});

		return TextGen.toCommaList(eventNameIter);
	}

	/**
	 *
	 */
	public Iterator getStyleAndEffectInitializerIterator()
	{
		return new IteratorChain(getStyleInitializerIterator(), getEffectInitializerIterator());
	}

	/**
	 *
	 */
	public final void setEvent(Event event, String text, int line)
	{
		document.addImport(NameFormatter.toDot(event.getType().getName()), line);

		EventHandler handler = new EventHandler(this, event, text);
		handler.setXmlLineNumber(line);

		EventInitializer eventInitializer = new EventInitializer(handler);

		(events != null ? events : (events = new LinkedHashMap())).put(event.getName(), eventInitializer);
	}

	public final Iterator getEventInitializerIterator()
	{
		return getEvents().values().iterator();
	}

	public final boolean hasEvent(String name)
	{
		return getEvents().containsKey(name);
	}

	private final Map getEvents()
	{
		return events != null ? events : Collections.EMPTY_MAP;
	}

	/**
	 *  iterator containing definitions from our initializers
	 */
	public Iterator getSubDefinitionsIterator()
	{
		IteratorList iterList = new IteratorList();

		addDefinitionIterators(iterList, getPropertyInitializerIterator());
		addDefinitionIterators(iterList, getStyleInitializerIterator());
		addDefinitionIterators(iterList, getEffectInitializerIterator());
		addDefinitionIterators(iterList, getEventInitializerIterator());

		return iterList.toIterator();
	}

	/**
	 *
	 */
	protected static void addDefinitionIterators(IteratorList iterList, Iterator initIter)
	{
		while (initIter.hasNext())
		{
			iterList.add(((Initializer)initIter.next()).getDefinitionsIterator());
		}
	}

	/**
	 *
	 */
	protected Iterator excludeBindings(Iterator iter)
	{
		return bindingFilter(iter, false);
	}

	/**
	 *
	 */
	protected Iterator bindingsOnly(Iterator iter)
	{
		return bindingFilter(iter, true);
	}

	/**
	 *
	 */
	protected Iterator bindingFilter(Iterator iter, final boolean include)
	{
		return new FilterIterator(iter, new Predicate()
		{
			public boolean evaluate(Object object)
			{
				return (((Initializer) object).isBinding()) == include;
			}
		});
	}

	/**
	 *
	 */
	public final void setDescribed(boolean described)
	{
		this.described = described;
        }

	/**
	 *
	 */
	public final boolean isDescribed()
	{
		return described;
	}
}
