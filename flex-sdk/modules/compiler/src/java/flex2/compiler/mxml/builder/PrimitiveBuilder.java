////////////////////////////////////////////////////////////////////////////////
//
//  ADOBE SYSTEMS INCORPORATED
//  Copyright 2005-2007 Adobe Systems Incorporated
//  All Rights Reserved.
//
//  NOTICE: Adobe permits you to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
//
////////////////////////////////////////////////////////////////////////////////

package flex2.compiler.mxml.builder;

import flex2.compiler.CompilationUnit;
import flex2.compiler.util.CompilerMessage.CompilerError;
import flex2.compiler.util.NameFormatter;
import flex2.compiler.mxml.Configuration;
import flex2.compiler.mxml.dom.*;
import flex2.compiler.mxml.lang.BindingHandler;
import flex2.compiler.mxml.lang.TextParser;
import flex2.compiler.mxml.reflect.Type;
import flex2.compiler.mxml.reflect.TypeTable;
import flex2.compiler.mxml.rep.BindingExpression;
import flex2.compiler.mxml.rep.MxmlDocument;
import flex2.compiler.mxml.rep.Primitive;

/**
 * TODO move processPrimitiveEntry logic to ComponentBuilder.analyze(PrimitiveNode), and kill this class
 *
 * @author Clement Wong
 */
class PrimitiveBuilder extends Builder
{
	PrimitiveBuilder(CompilationUnit unit, TypeTable typeTable, Configuration configuration, MxmlDocument document,
					 boolean topLevel, BindingHandler bindingHandler)
	{
		super(unit, typeTable, configuration, document);
		this.topLevel = topLevel;
		this.bindingHandler = bindingHandler;
	}

	protected boolean topLevel;
	protected BindingHandler bindingHandler;
	Primitive value;

	public void analyze(StringNode node)
	{
		processPrimitiveEntry(node);
	}

	public void analyze(NumberNode node)
	{
		processPrimitiveEntry(node);
	}

    public void analyze(IntNode node)
    {
        processPrimitiveEntry(node);
    }
    public void analyze(UIntNode node)
    {
        processPrimitiveEntry(node);
    }


    public void analyze(BooleanNode node)
	{
		processPrimitiveEntry(node);
	}

	public void analyze(ClassNode node)
	{
		processPrimitiveEntry(node);
	}

	public void analyze(FunctionNode node)
	{
		processPrimitiveEntry(node);
	}

	private void processPrimitiveEntry(PrimitiveNode node)
	{
		Type type = nodeTypeResolver.resolveType(node);

		Primitive primitive = initPrimitiveValue(type, node);

		CDATANode cdata = getTextContent(node.getChildren(), false);
		if (cdata != null)
		{
			processTextInitializer(cdata.image, type, cdata.inCDATA, cdata.beginLine);
		}
		else
		{
			//	NOTE: our scanner gives us identical representations for <tag/> and <tag></tag>. Here is one place where
			//	that's suboptimal for usability. TODO worth doing something about?
			if (!topLevel)
			{
				if (typeTable.stringType.isAssignableTo(type))
				{
					processTextInitializer("", type, true, node.beginLine);
				}
				else
				{
					log(node.beginLine, new InitializerRequired());
				}
			}
		}

		String id = (String)node.getAttribute("id");
		if (id != null || topLevel)
		{
			if (primitive.getValue() != null)
			{
				registerModel(node, primitive, topLevel);
			}
			else
			{
				//	Note: primitives are currently the only kind of MXML tag that can be declared without initializing.
				//	TODO still, we should generalize 'register' to include uninitialized declarations
				boolean autogenerated = false;
				if (id == null)
				{
					//	anon id has been generated
					autogenerated = true;
					id = primitive.getId();
				}

				document.addDeclaration(id, type.getName(), node.beginLine, true, topLevel, autogenerated);
			}
		}

	}

	/**
	 *
	 */
	private Primitive initPrimitiveValue(Type type, PrimitiveNode node)
	{
		Primitive primitive = new Primitive(document, type, node.beginLine);
		primitive.setInspectable(true);

		value = primitive;

		return primitive;
	}

	/**
	 *
	 */
	public void processTextInitializer(String text, Type type, boolean cdata, int line)
	{
		int flags = cdata ? TextParser.FlagInCDATA : 0;
		Object result = textParser.parseValue(text, type, flags, line, NameFormatter.toDot(type.getName()));

		if (result != null)
		{
			/**
			 * Note: we've already set up a Primitive to recieve parsed value or function as binding dest.
			 */
			if (result instanceof BindingExpression)
			{
				if (bindingHandler != null)
				{
					bindingHandler.invoke((BindingExpression)result, value);
				}
				else
				{
					log(new BindingNotAllowed());
				}
			}

			value.setValue(result);
		}
	}

    public static class InitializerRequired extends CompilerError
    {
    }
}
