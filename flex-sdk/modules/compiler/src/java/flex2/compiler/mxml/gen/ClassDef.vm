################################################################################
##
##  ADOBE SYSTEMS INCORPORATED
##  Copyright 2004-2007 Adobe Systems Incorporated
##  All Rights Reserved.
##
##  NOTICE: Adobe permits you to use, modify, and distribute this file
##  in accordance with the terms of the license agreement accompanying it.
##
################################################################################

#*
	ClassDef.vm

	Template for an AS3 class definition given (MxmlDocument $doc, VelocityUtil $util)

	Library macros defined in ClassDefLib.vm
*#/**
 * 	Generated by mxmlc 2.0
 *
 *	Package:	$doc.packageName
 *	Class: 		$doc.className
 *	Source: 	$doc.sourcePath
 *	Template: 	${util.templatePath}ClassDef.vm
 *	Time: 		$util.timeStamp
 */

##
## begin package def
##
package $doc.packageName
{

##
## imports
##
#foreach ($nameInfo in $doc.imports)
## NOTE: the SWC contains actual, debuggable bytecode for import statements. To avoid unwanted
## BPs in the debugger, we use an explicitly compile-error-only mapping here.
#embedTextMapCompileErrorsOnly("import $nameInfo.name;" $nameInfo.line)
#end

##
## ResourceBundle metadata autogenerated from @Resource directives
##
#foreach ($atResource in $doc.atResources)
[ResourceBundle("$atResource.bundle")]
#end

##
## metadata - may be internal or from <Metdata>; latter will be line-number mapped by embedText
##
#foreach ($md in $doc.metadata)
#embedText($md.Text $md.xmlLineNumber)
#end

##
## begin class def
##
#trace("//	begin class def")

#embedText("public class $doc.className" $doc.root.xmlLineNumber)
#embedText("	extends $doc.superClassName" $doc.root.xmlLineNumber)
#if ($doc.hasInterfaces)
#embedText("	implements $doc.interfaceList" $doc.root.xmlLineNumber)
#end
{

##
## instance var declarations
##
#trace("	//	instance variables")
#foreach ($decl in $doc.declarationIterator)
#if ($decl.inspectable)
#embedText("	[Inspectable]" $decl.lineRef)
#end
#if (!$decl.idIsAutogenerated)
#embedText("	[Bindable]" $decl.lineRef)
#end
## NOTE: the SWC contains actual, debuggable bytecode for empty variable declarations. To avoid unwanted
## BPs in the debugger, we use an explicitly compile-error-only mapping here.
/**
 * @private
 **/
#embedTextMapCompileErrorsOnly("	public var $decl.name : $decl.typeExpr;" $decl.lineRef)

#end

#trace("	//	type-import dummies")
#foreach ($typeName in $doc.typeRefs)
    private var _typeRef$velocityCount : $typeName;
#end

##
##	construct/init
##
#if ($doc.isIUIComponent)

#if ($doc.describeVisualChildren && $doc.isContainer)
##
## Note that we line-map this code for compile errors only. This is so that
## BPs set on MXML tags don't fire on startup. However, it also means that
## any RTEs will not point back to the defining tag. 
##
#trace("	//	Container document descriptor")
#foreach ($frag in $doc.getDescriptorDeclaration("_documentDescriptor_"))
#embedTextMapCompileErrorsOnly($frag.Text $frag.xmlLineNumber)
#end
#end

#trace("	//	constructor (Flex display object)")
    /**
     * @private
     **/
	public function ${doc.className}()
	{
		super();

#if ($doc.isContainer)
##		The _document variable needs to be set earlier than
##		initialize(), because children can access their
##		parent's document in UIComponent.executeBindings(),
##		which is called via initialize() and initialization
##		currently happens bottom up.
		mx_internal::_document = this;
#end
#emitComponentInitializers_1()
	}

#trace("	//	initialize()")
    /**
     * @private
     **/
	override public function initialize():void
	{
#if ($doc.describeVisualChildren && $doc.isContainer)
##
##		Note: setDocumentDescriptor() ensures that visual children are defined by
##		at most one documentDescriptor, as we call super.initialize() upwards through
##		the derivation chain. If more than one set of child descriptors is encountered,
##		an RTE is thrown.
##
 		mx_internal::setDocumentDescriptor(_documentDescriptor_);
#end
#emitComponentInitializers_2()
		super.initialize();
	}
#else

##
##	non-UIComponent construct/init codegen
##	TODO this is just a placeholder for a non-UIComponent component constructor. Details entirely TBD
##

#trace("	//	constructor (non-Flex display object)")
    /**
     * @private
     **/
	public function ${doc.className}()
	{
	    super();

#emitComponentInitializers_1()
#emitComponentInitializers_2()
	}
#end

##
## scripts
##
#trace("	//	scripts")
#foreach ($script in $doc.scripts)
#trace("	//	<Script>, line $script.xmlLineNumber - $script.endXmlLineNumber")
#embedText($script.Text $script.xmlLineNumber)

#end
#trace("	//	end scripts")

##
## initializer support defs
##
#emitInitializerSupportDefs()

##
## @Embeds
##
#trace("	//	embed carrier vars")
#foreach ($atEmbed in $doc.atEmbeds)
#emitEmbedMetadata($atEmbed) private var $atEmbed.propName:$atEmbed.type;

#end
#trace("	//	end embed carrier vars")

##
## misc hardcoded stuff
##
#if ($doc.bindingExpressions.size() > 0)
#trace("	//	binding management vars")
#foreach ($var in $doc.bindingManagementVars)
#if (!$doc.superHasPublicProperty($var.name))
    /**
     * @private
     **/
    $var.namespace var $var.name : $var.type = $var.initializer;
#end
#end
#end

##
## end class def
##
#trace("//	end class def")
}

##
## end package def
##
#trace("//	end package def")
}
